// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hellofresh/goengine/driver/sql (interfaces: NotificationQueuer)

// Package sql is a generated GoMock package.
package sql

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	sql "github.com/hellofresh/goengine/driver/sql"
	reflect "reflect"
)

// NotificationQueuer is a mock of NotificationQueuer interface
type NotificationQueuer struct {
	ctrl     *gomock.Controller
	recorder *NotificationQueuerMockRecorder
}

// NotificationQueuerMockRecorder is the mock recorder for NotificationQueuer
type NotificationQueuerMockRecorder struct {
	mock *NotificationQueuer
}

// NewNotificationQueuer creates a new mock instance
func NewNotificationQueuer(ctrl *gomock.Controller) *NotificationQueuer {
	mock := &NotificationQueuer{ctrl: ctrl}
	mock.recorder = &NotificationQueuerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *NotificationQueuer) EXPECT() *NotificationQueuerMockRecorder {
	return m.recorder
}

// Channel mocks base method
func (m *NotificationQueuer) Channel() chan *sql.ProjectionNotification {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Channel")
	ret0, _ := ret[0].(chan *sql.ProjectionNotification)
	return ret0
}

// Channel indicates an expected call of Channel
func (mr *NotificationQueuerMockRecorder) Channel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Channel", reflect.TypeOf((*NotificationQueuer)(nil).Channel))
}

// Close mocks base method
func (m *NotificationQueuer) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close
func (mr *NotificationQueuerMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*NotificationQueuer)(nil).Close))
}

// Empty mocks base method
func (m *NotificationQueuer) Empty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Empty indicates an expected call of Empty
func (mr *NotificationQueuerMockRecorder) Empty() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*NotificationQueuer)(nil).Empty))
}

// Open mocks base method
func (m *NotificationQueuer) Open(arg0 chan struct{}) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Open", arg0)
}

// Open indicates an expected call of Open
func (mr *NotificationQueuerMockRecorder) Open(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*NotificationQueuer)(nil).Open), arg0)
}

// PutBack mocks base method
func (m *NotificationQueuer) PutBack(arg0 *sql.ProjectionNotification) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PutBack", arg0)
}

// PutBack indicates an expected call of PutBack
func (mr *NotificationQueuerMockRecorder) PutBack(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PutBack", reflect.TypeOf((*NotificationQueuer)(nil).PutBack), arg0)
}

// Queue mocks base method
func (m *NotificationQueuer) Queue(arg0 context.Context, arg1 *sql.ProjectionNotification) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Queue", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Queue indicates an expected call of Queue
func (mr *NotificationQueuerMockRecorder) Queue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Queue", reflect.TypeOf((*NotificationQueuer)(nil).Queue), arg0, arg1)
}

// ReQueue mocks base method
func (m *NotificationQueuer) ReQueue(arg0 context.Context, arg1 *sql.ProjectionNotification) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReQueue", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReQueue indicates an expected call of ReQueue
func (mr *NotificationQueuerMockRecorder) ReQueue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReQueue", reflect.TypeOf((*NotificationQueuer)(nil).ReQueue), arg0, arg1)
}
